{"ast":null,"code":"import { useRef, useCallback, useEffect } from 'react';\nimport { getWidth, getHeight, getOffset } from 'dom-lib';\nimport { SCROLLBAR_WIDTH } from '../constants';\nimport debounce from 'lodash/debounce';\nimport bindElementResize, { unbind as unbindElementResize } from 'element-resize-event';\nimport useMount from './useMount';\nimport useUpdateLayoutEffect from './useUpdateLayoutEffect';\nimport isNumberOrTrue from './isNumberOrTrue';\n/**\n * The dimension information of the table,\n * including the height, width, scrollable distance and the coordinates of the scroll handle, etc.\n * @param props\n * @returns\n */\n\nvar useTableDimension = function useTableDimension(props) {\n  var data = props.data,\n      rowHeight = props.rowHeight,\n      tableRef = props.tableRef,\n      headerWrapperRef = props.headerWrapperRef,\n      prefix = props.prefix,\n      widthProp = props.width,\n      affixHeader = props.affixHeader,\n      affixHorizontalScrollbar = props.affixHorizontalScrollbar,\n      headerHeight = props.headerHeight,\n      height = props.height,\n      autoHeight = props.autoHeight,\n      children = props.children,\n      expandedRowKeys = props.expandedRowKeys,\n      onTableWidthChange = props.onTableWidthChange,\n      onTableContentWidthChange = props.onTableContentWidthChange,\n      onTableContentHeightChange = props.onTableContentHeightChange,\n      onTableScroll = props.onTableScroll;\n  var contentHeight = useRef(0);\n  var contentWidth = useRef(0);\n  var minScrollY = useRef(0);\n  var scrollY = useRef(0);\n  var scrollX = useRef(0);\n  var minScrollX = useRef(0);\n  var tableWidth = useRef(widthProp || 0);\n  var headerOffset = useRef(null);\n  var tableOffset = useRef(null);\n  var calculateTableContextHeight = useCallback(function () {\n    var prevContentHeight = contentHeight.current;\n    var table = tableRef.current;\n    var rows = table.querySelectorAll(\".\" + prefix('row')) || [];\n    var nextContentHeight = rows.length ? Array.from(rows).map(function (row) {\n      return getHeight(row) || rowHeight;\n    }).reduce(function (x, y) {\n      return x + y;\n    }) : 0; // After setting the affixHeader property, the height of the two headers should be subtracted.\n\n    contentHeight.current = nextContentHeight - (affixHeader ? headerHeight * 2 : headerHeight);\n\n    if (!autoHeight) {\n      /**\n       *  The purpose of subtracting SCROLLBAR_WIDTH is to keep the scroll bar from blocking the content part.\n       *  But it will only be calculated when there is a horizontal scroll bar (contentWidth > tableWidth).\n       */\n      minScrollY.current = -(nextContentHeight - height) - (contentWidth.current > tableWidth.current ? SCROLLBAR_WIDTH : 0);\n    } // If the height of the content area is less than the height of the table, the vertical scroll bar is reset.\n\n\n    if (nextContentHeight < height) {\n      onTableScroll({\n        y: 0\n      });\n    } // If the value of scrollTop is greater than the scrollable range, the vertical scroll bar is reset.\n    // When Table is set to virtualized, the logic will be entered every time the wheel event is triggered\n    // to avoid resetting the scroll bar after scrolling to the bottom, so add the SCROLLBAR_WIDTH value.\n\n\n    if (Math.abs(scrollY.current) + height - headerHeight > nextContentHeight + SCROLLBAR_WIDTH) {\n      onTableScroll({\n        y: scrollY.current\n      });\n    }\n\n    if (prevContentHeight !== contentHeight.current) {\n      onTableContentHeightChange(prevContentHeight);\n    }\n  }, [affixHeader, autoHeight, headerHeight, height, onTableScroll, onTableContentHeightChange, prefix, rowHeight, tableRef]);\n  var setOffsetByAffix = useCallback(function () {\n    var headerNode = headerWrapperRef === null || headerWrapperRef === void 0 ? void 0 : headerWrapperRef.current;\n\n    if (isNumberOrTrue(affixHeader) && headerNode) {\n      headerOffset.current = getOffset(headerNode);\n    }\n\n    if (isNumberOrTrue(affixHorizontalScrollbar) && tableRef !== null && tableRef !== void 0 && tableRef.current) {\n      tableOffset.current = getOffset(tableRef === null || tableRef === void 0 ? void 0 : tableRef.current);\n    }\n  }, [affixHeader, affixHorizontalScrollbar, headerWrapperRef, tableRef]);\n  var calculateTableContentWidth = useCallback(function () {\n    var prevWidth = contentWidth.current;\n    var table = tableRef === null || tableRef === void 0 ? void 0 : tableRef.current;\n    var row = table.querySelector(\".\" + prefix('row') + \":not(.virtualized)\");\n    var nextContentWidth = row ? getWidth(row) : 0;\n    contentWidth.current = nextContentWidth; // The value of SCROLLBAR_WIDTH is subtracted so that the scroll bar does not block the content part.\n    // There is no vertical scroll bar after autoHeight.\n\n    minScrollX.current = -(nextContentWidth - tableWidth.current) - (autoHeight ? 0 : SCROLLBAR_WIDTH);\n\n    if (prevWidth !== contentWidth.current) {\n      onTableContentWidthChange(prevWidth);\n    }\n  }, [autoHeight, onTableContentWidthChange, prefix, tableRef]);\n  var calculateTableWidth = useCallback(function () {\n    var prevWidth = tableWidth.current;\n\n    if (tableRef !== null && tableRef !== void 0 && tableRef.current) {\n      var nextWidth = getWidth(tableRef === null || tableRef === void 0 ? void 0 : tableRef.current);\n      tableWidth.current = nextWidth;\n    }\n\n    if (prevWidth !== tableWidth.current) {\n      scrollX.current = 0;\n      onTableWidthChange === null || onTableWidthChange === void 0 ? void 0 : onTableWidthChange(prevWidth);\n    }\n\n    setOffsetByAffix();\n  }, [onTableWidthChange, setOffsetByAffix, tableRef]);\n  useMount(function () {\n    calculateTableContextHeight();\n    calculateTableContentWidth();\n    calculateTableWidth();\n    setOffsetByAffix();\n    bindElementResize(tableRef.current, debounce(calculateTableWidth, 400));\n  });\n  useUpdateLayoutEffect(function () {\n    calculateTableWidth();\n    calculateTableContextHeight();\n    calculateTableContentWidth();\n  }, [data, height, contentHeight, expandedRowKeys, children, calculateTableContextHeight, calculateTableContentWidth]);\n  useEffect(function () {\n    return function () {\n      if (tableRef.current) {\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        unbindElementResize(tableRef.current);\n      }\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  var setScrollY = useCallback(function (value) {\n    scrollY.current = value;\n  }, []);\n  var setScrollX = useCallback(function (value) {\n    scrollX.current = value;\n  }, []);\n  return {\n    contentHeight: contentHeight,\n    contentWidth: contentWidth,\n    minScrollY: minScrollY,\n    minScrollX: minScrollX,\n    scrollY: scrollY,\n    scrollX: scrollX,\n    tableWidth: tableWidth,\n    headerOffset: headerOffset,\n    tableOffset: tableOffset,\n    setScrollY: setScrollY,\n    setScrollX: setScrollX\n  };\n};\n\nexport default useTableDimension;","map":{"version":3,"sources":["/mnt/c/Users/moham/documents/CSE 3311/Team9Project/node_modules/rsuite-table/es/utils/useTableDimension.js"],"names":["useRef","useCallback","useEffect","getWidth","getHeight","getOffset","SCROLLBAR_WIDTH","debounce","bindElementResize","unbind","unbindElementResize","useMount","useUpdateLayoutEffect","isNumberOrTrue","useTableDimension","props","data","rowHeight","tableRef","headerWrapperRef","prefix","widthProp","width","affixHeader","affixHorizontalScrollbar","headerHeight","height","autoHeight","children","expandedRowKeys","onTableWidthChange","onTableContentWidthChange","onTableContentHeightChange","onTableScroll","contentHeight","contentWidth","minScrollY","scrollY","scrollX","minScrollX","tableWidth","headerOffset","tableOffset","calculateTableContextHeight","prevContentHeight","current","table","rows","querySelectorAll","nextContentHeight","length","Array","from","map","row","reduce","x","y","Math","abs","setOffsetByAffix","headerNode","calculateTableContentWidth","prevWidth","querySelector","nextContentWidth","calculateTableWidth","nextWidth","setScrollY","value","setScrollX"],"mappings":"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","sourcesContent":["import { useRef, useCallback, useEffect } from 'react';\nimport { getWidth, getHeight, getOffset } from 'dom-lib';\nimport { SCROLLBAR_WIDTH } from '../constants';\nimport debounce from 'lodash/debounce';\nimport bindElementResize, { unbind as unbindElementResize } from 'element-resize-event';\nimport useMount from './useMount';\nimport useUpdateLayoutEffect from './useUpdateLayoutEffect';\nimport isNumberOrTrue from './isNumberOrTrue';\n\n/**\n * The dimension information of the table,\n * including the height, width, scrollable distance and the coordinates of the scroll handle, etc.\n * @param props\n * @returns\n */\nvar useTableDimension = function useTableDimension(props) {\n  var data = props.data,\n      rowHeight = props.rowHeight,\n      tableRef = props.tableRef,\n      headerWrapperRef = props.headerWrapperRef,\n      prefix = props.prefix,\n      widthProp = props.width,\n      affixHeader = props.affixHeader,\n      affixHorizontalScrollbar = props.affixHorizontalScrollbar,\n      headerHeight = props.headerHeight,\n      height = props.height,\n      autoHeight = props.autoHeight,\n      children = props.children,\n      expandedRowKeys = props.expandedRowKeys,\n      onTableWidthChange = props.onTableWidthChange,\n      onTableContentWidthChange = props.onTableContentWidthChange,\n      onTableContentHeightChange = props.onTableContentHeightChange,\n      onTableScroll = props.onTableScroll;\n  var contentHeight = useRef(0);\n  var contentWidth = useRef(0);\n  var minScrollY = useRef(0);\n  var scrollY = useRef(0);\n  var scrollX = useRef(0);\n  var minScrollX = useRef(0);\n  var tableWidth = useRef(widthProp || 0);\n  var headerOffset = useRef(null);\n  var tableOffset = useRef(null);\n  var calculateTableContextHeight = useCallback(function () {\n    var prevContentHeight = contentHeight.current;\n    var table = tableRef.current;\n    var rows = table.querySelectorAll(\".\" + prefix('row')) || [];\n    var nextContentHeight = rows.length ? Array.from(rows).map(function (row) {\n      return getHeight(row) || rowHeight;\n    }).reduce(function (x, y) {\n      return x + y;\n    }) : 0; // After setting the affixHeader property, the height of the two headers should be subtracted.\n\n    contentHeight.current = nextContentHeight - (affixHeader ? headerHeight * 2 : headerHeight);\n\n    if (!autoHeight) {\n      /**\n       *  The purpose of subtracting SCROLLBAR_WIDTH is to keep the scroll bar from blocking the content part.\n       *  But it will only be calculated when there is a horizontal scroll bar (contentWidth > tableWidth).\n       */\n      minScrollY.current = -(nextContentHeight - height) - (contentWidth.current > tableWidth.current ? SCROLLBAR_WIDTH : 0);\n    } // If the height of the content area is less than the height of the table, the vertical scroll bar is reset.\n\n\n    if (nextContentHeight < height) {\n      onTableScroll({\n        y: 0\n      });\n    } // If the value of scrollTop is greater than the scrollable range, the vertical scroll bar is reset.\n    // When Table is set to virtualized, the logic will be entered every time the wheel event is triggered\n    // to avoid resetting the scroll bar after scrolling to the bottom, so add the SCROLLBAR_WIDTH value.\n\n\n    if (Math.abs(scrollY.current) + height - headerHeight > nextContentHeight + SCROLLBAR_WIDTH) {\n      onTableScroll({\n        y: scrollY.current\n      });\n    }\n\n    if (prevContentHeight !== contentHeight.current) {\n      onTableContentHeightChange(prevContentHeight);\n    }\n  }, [affixHeader, autoHeight, headerHeight, height, onTableScroll, onTableContentHeightChange, prefix, rowHeight, tableRef]);\n  var setOffsetByAffix = useCallback(function () {\n    var headerNode = headerWrapperRef === null || headerWrapperRef === void 0 ? void 0 : headerWrapperRef.current;\n\n    if (isNumberOrTrue(affixHeader) && headerNode) {\n      headerOffset.current = getOffset(headerNode);\n    }\n\n    if (isNumberOrTrue(affixHorizontalScrollbar) && tableRef !== null && tableRef !== void 0 && tableRef.current) {\n      tableOffset.current = getOffset(tableRef === null || tableRef === void 0 ? void 0 : tableRef.current);\n    }\n  }, [affixHeader, affixHorizontalScrollbar, headerWrapperRef, tableRef]);\n  var calculateTableContentWidth = useCallback(function () {\n    var prevWidth = contentWidth.current;\n    var table = tableRef === null || tableRef === void 0 ? void 0 : tableRef.current;\n    var row = table.querySelector(\".\" + prefix('row') + \":not(.virtualized)\");\n    var nextContentWidth = row ? getWidth(row) : 0;\n    contentWidth.current = nextContentWidth; // The value of SCROLLBAR_WIDTH is subtracted so that the scroll bar does not block the content part.\n    // There is no vertical scroll bar after autoHeight.\n\n    minScrollX.current = -(nextContentWidth - tableWidth.current) - (autoHeight ? 0 : SCROLLBAR_WIDTH);\n\n    if (prevWidth !== contentWidth.current) {\n      onTableContentWidthChange(prevWidth);\n    }\n  }, [autoHeight, onTableContentWidthChange, prefix, tableRef]);\n  var calculateTableWidth = useCallback(function () {\n    var prevWidth = tableWidth.current;\n\n    if (tableRef !== null && tableRef !== void 0 && tableRef.current) {\n      var nextWidth = getWidth(tableRef === null || tableRef === void 0 ? void 0 : tableRef.current);\n      tableWidth.current = nextWidth;\n    }\n\n    if (prevWidth !== tableWidth.current) {\n      scrollX.current = 0;\n      onTableWidthChange === null || onTableWidthChange === void 0 ? void 0 : onTableWidthChange(prevWidth);\n    }\n\n    setOffsetByAffix();\n  }, [onTableWidthChange, setOffsetByAffix, tableRef]);\n  useMount(function () {\n    calculateTableContextHeight();\n    calculateTableContentWidth();\n    calculateTableWidth();\n    setOffsetByAffix();\n    bindElementResize(tableRef.current, debounce(calculateTableWidth, 400));\n  });\n  useUpdateLayoutEffect(function () {\n    calculateTableWidth();\n    calculateTableContextHeight();\n    calculateTableContentWidth();\n  }, [data, height, contentHeight, expandedRowKeys, children, calculateTableContextHeight, calculateTableContentWidth]);\n  useEffect(function () {\n    return function () {\n      if (tableRef.current) {\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        unbindElementResize(tableRef.current);\n      }\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  var setScrollY = useCallback(function (value) {\n    scrollY.current = value;\n  }, []);\n  var setScrollX = useCallback(function (value) {\n    scrollX.current = value;\n  }, []);\n  return {\n    contentHeight: contentHeight,\n    contentWidth: contentWidth,\n    minScrollY: minScrollY,\n    minScrollX: minScrollX,\n    scrollY: scrollY,\n    scrollX: scrollX,\n    tableWidth: tableWidth,\n    headerOffset: headerOffset,\n    tableOffset: tableOffset,\n    setScrollY: setScrollY,\n    setScrollX: setScrollX\n  };\n};\n\nexport default useTableDimension;"]},"metadata":{},"sourceType":"module"}