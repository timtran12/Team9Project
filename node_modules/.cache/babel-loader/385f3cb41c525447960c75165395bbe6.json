{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _isNil from \"lodash/isNil\";\nimport { shallowEqual, CHECK_STATE } from '../utils';\nimport { getChildrenByFlattenNodes } from '../utils/treeUtils';\nexport function isEveryChildChecked(nodes, parent) {\n  if (_isNil(nodes[parent.refKey])) {\n    return false;\n  }\n\n  var children = getChildrenByFlattenNodes(nodes, parent);\n\n  if (!children.length) {\n    return nodes[parent.refKey].check;\n  }\n\n  return children.every(function (child) {\n    return nodes[child.refKey].check;\n  });\n}\nexport function isSomeChildChecked(nodes, parent) {\n  if (_isNil(nodes[parent.refKey])) {\n    return false;\n  }\n\n  var children = getChildrenByFlattenNodes(nodes, parent);\n\n  if (!children.length) {\n    return nodes[parent.refKey].check;\n  }\n\n  return children.some(function (child) {\n    return nodes[child.refKey].check;\n  });\n}\nexport function isSomeNodeHasChildren(data, childrenKey) {\n  return data.some(function (node) {\n    return node[childrenKey];\n  });\n}\n/**\n * is all siblings nodes is uncheckable\n * @param {*} node\n */\n\nexport function isAllSiblingNodeUncheckable(node, nodes, uncheckableItemValues, valueKey) {\n  var list = [];\n  var parentNodeRefkey = node.parent ? node.parent.refKey : '';\n  Object.keys(nodes).forEach(function (refKey) {\n    var _curNode$parent;\n\n    var curNode = nodes[refKey];\n\n    if (_isNil(node.parent) && _isNil(curNode.parent)) {\n      list.push(curNode);\n    } else if (((_curNode$parent = curNode.parent) === null || _curNode$parent === void 0 ? void 0 : _curNode$parent.refKey) === parentNodeRefkey) {\n      list.push(curNode);\n    }\n  });\n  return list.every(function (node) {\n    return isNodeUncheckable(node, {\n      uncheckableItemValues: uncheckableItemValues,\n      valueKey: valueKey\n    });\n  });\n}\n/**\n * get each first level node uncheckable state\n */\n\nexport function isEveryFirstLevelNodeUncheckable(nodes, uncheckableItemValues, valueKey) {\n  var list = [];\n  Object.keys(nodes).forEach(function (refKey) {\n    var curNode = nodes[refKey];\n\n    if (!curNode.parent) {\n      list.push(curNode);\n    }\n  });\n  return list.every(function (node) {\n    return isNodeUncheckable(node, {\n      uncheckableItemValues: uncheckableItemValues,\n      valueKey: valueKey\n    });\n  });\n}\n/**\n * get node uncheckable state\n * @param {*} node\n */\n\nexport function isNodeUncheckable(node, props) {\n  var _props$uncheckableIte = props.uncheckableItemValues,\n      uncheckableItemValues = _props$uncheckableIte === void 0 ? [] : _props$uncheckableIte,\n      valueKey = props.valueKey;\n  return uncheckableItemValues.some(function (value) {\n    return shallowEqual(node[valueKey], value);\n  });\n}\nexport function getFormattedTree(data, nodes, props) {\n  var childrenKey = props.childrenKey,\n      cascade = props.cascade;\n  return data.map(function (node) {\n    var formatted = _extends({}, node);\n\n    var curNode = nodes[node.refKey];\n\n    if (curNode) {\n      var _node$childrenKey;\n\n      var checkState = !_isUndefined(cascade) ? getNodeCheckState({\n        node: curNode,\n        cascade: cascade,\n        nodes: nodes,\n        childrenKey: childrenKey\n      }) : undefined;\n      formatted.check = curNode.check;\n      formatted.expand = curNode.expand;\n      formatted.uncheckable = curNode.uncheckable;\n      formatted.parent = curNode.parent;\n      formatted.checkState = checkState;\n\n      if (((_node$childrenKey = node[childrenKey]) === null || _node$childrenKey === void 0 ? void 0 : _node$childrenKey.length) > 0) {\n        formatted[childrenKey] = getFormattedTree(formatted[childrenKey], nodes, props);\n      }\n    }\n\n    return formatted;\n  });\n}\nexport function getDisabledState(nodes, node, props) {\n  var _props$disabledItemVa = props.disabledItemValues,\n      disabledItemValues = _props$disabledItemVa === void 0 ? [] : _props$disabledItemVa,\n      valueKey = props.valueKey;\n\n  if (_isNil(nodes[node.refKey])) {\n    return false;\n  }\n\n  return disabledItemValues.some(function (value) {\n    return shallowEqual(nodes[node.refKey][valueKey], value);\n  });\n}\nexport function getCheckTreePickerDefaultValue(value, uncheckableItemValues) {\n  if (Array.isArray(value)) {\n    return value.filter(function (v) {\n      return !uncheckableItemValues.includes(v);\n    });\n  }\n\n  return [];\n}\nexport function getSelectedItems(nodes, value, valueKey) {\n  var checkItems = [];\n  Object.keys(nodes).map(function (refKey) {\n    var node = nodes[refKey];\n\n    if (value.some(function (value) {\n      return shallowEqual(node[valueKey], value);\n    })) {\n      checkItems.push(node);\n    }\n  });\n  return checkItems;\n}\nexport function getNodeCheckState(_ref) {\n  var nodes = _ref.nodes,\n      node = _ref.node,\n      cascade = _ref.cascade,\n      childrenKey = _ref.childrenKey;\n\n  if (_isNil(nodes[node.refKey])) {\n    return CHECK_STATE.UNCHECK;\n  }\n\n  if (!node[childrenKey] || !node[childrenKey].length || !cascade) {\n    nodes[node.refKey].checkAll = false;\n    return node.check ? CHECK_STATE.CHECK : CHECK_STATE.UNCHECK;\n  }\n\n  if (isEveryChildChecked(nodes, node)) {\n    nodes[node.refKey].checkAll = true;\n    nodes[node.refKey].check = true;\n    return CHECK_STATE.CHECK;\n  }\n\n  if (isSomeChildChecked(nodes, node)) {\n    nodes[node.refKey].checkAll = false;\n    return CHECK_STATE.INDETERMINATE;\n  }\n\n  return CHECK_STATE.UNCHECK;\n}","map":{"version":3,"sources":["/mnt/c/Users/moham/documents/CSE 3311/Team9Project/node_modules/rsuite/esm/CheckTreePicker/utils.js"],"names":["_extends","_isUndefined","_isNil","shallowEqual","CHECK_STATE","getChildrenByFlattenNodes","isEveryChildChecked","nodes","parent","refKey","children","length","check","every","child","isSomeChildChecked","some","isSomeNodeHasChildren","data","childrenKey","node","isAllSiblingNodeUncheckable","uncheckableItemValues","valueKey","list","parentNodeRefkey","Object","keys","forEach","_curNode$parent","curNode","push","isNodeUncheckable","isEveryFirstLevelNodeUncheckable","props","_props$uncheckableIte","value","getFormattedTree","cascade","map","formatted","_node$childrenKey","checkState","getNodeCheckState","undefined","expand","uncheckable","getDisabledState","_props$disabledItemVa","disabledItemValues","getCheckTreePickerDefaultValue","Array","isArray","filter","v","includes","getSelectedItems","checkItems","_ref","UNCHECK","checkAll","CHECK","INDETERMINATE"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _isNil from \"lodash/isNil\";\nimport { shallowEqual, CHECK_STATE } from '../utils';\nimport { getChildrenByFlattenNodes } from '../utils/treeUtils';\nexport function isEveryChildChecked(nodes, parent) {\n  if (_isNil(nodes[parent.refKey])) {\n    return false;\n  }\n\n  var children = getChildrenByFlattenNodes(nodes, parent);\n\n  if (!children.length) {\n    return nodes[parent.refKey].check;\n  }\n\n  return children.every(function (child) {\n    return nodes[child.refKey].check;\n  });\n}\nexport function isSomeChildChecked(nodes, parent) {\n  if (_isNil(nodes[parent.refKey])) {\n    return false;\n  }\n\n  var children = getChildrenByFlattenNodes(nodes, parent);\n\n  if (!children.length) {\n    return nodes[parent.refKey].check;\n  }\n\n  return children.some(function (child) {\n    return nodes[child.refKey].check;\n  });\n}\nexport function isSomeNodeHasChildren(data, childrenKey) {\n  return data.some(function (node) {\n    return node[childrenKey];\n  });\n}\n/**\n * is all siblings nodes is uncheckable\n * @param {*} node\n */\n\nexport function isAllSiblingNodeUncheckable(node, nodes, uncheckableItemValues, valueKey) {\n  var list = [];\n  var parentNodeRefkey = node.parent ? node.parent.refKey : '';\n  Object.keys(nodes).forEach(function (refKey) {\n    var _curNode$parent;\n\n    var curNode = nodes[refKey];\n\n    if (_isNil(node.parent) && _isNil(curNode.parent)) {\n      list.push(curNode);\n    } else if (((_curNode$parent = curNode.parent) === null || _curNode$parent === void 0 ? void 0 : _curNode$parent.refKey) === parentNodeRefkey) {\n      list.push(curNode);\n    }\n  });\n  return list.every(function (node) {\n    return isNodeUncheckable(node, {\n      uncheckableItemValues: uncheckableItemValues,\n      valueKey: valueKey\n    });\n  });\n}\n/**\n * get each first level node uncheckable state\n */\n\nexport function isEveryFirstLevelNodeUncheckable(nodes, uncheckableItemValues, valueKey) {\n  var list = [];\n  Object.keys(nodes).forEach(function (refKey) {\n    var curNode = nodes[refKey];\n\n    if (!curNode.parent) {\n      list.push(curNode);\n    }\n  });\n  return list.every(function (node) {\n    return isNodeUncheckable(node, {\n      uncheckableItemValues: uncheckableItemValues,\n      valueKey: valueKey\n    });\n  });\n}\n/**\n * get node uncheckable state\n * @param {*} node\n */\n\nexport function isNodeUncheckable(node, props) {\n  var _props$uncheckableIte = props.uncheckableItemValues,\n      uncheckableItemValues = _props$uncheckableIte === void 0 ? [] : _props$uncheckableIte,\n      valueKey = props.valueKey;\n  return uncheckableItemValues.some(function (value) {\n    return shallowEqual(node[valueKey], value);\n  });\n}\nexport function getFormattedTree(data, nodes, props) {\n  var childrenKey = props.childrenKey,\n      cascade = props.cascade;\n  return data.map(function (node) {\n    var formatted = _extends({}, node);\n\n    var curNode = nodes[node.refKey];\n\n    if (curNode) {\n      var _node$childrenKey;\n\n      var checkState = !_isUndefined(cascade) ? getNodeCheckState({\n        node: curNode,\n        cascade: cascade,\n        nodes: nodes,\n        childrenKey: childrenKey\n      }) : undefined;\n      formatted.check = curNode.check;\n      formatted.expand = curNode.expand;\n      formatted.uncheckable = curNode.uncheckable;\n      formatted.parent = curNode.parent;\n      formatted.checkState = checkState;\n\n      if (((_node$childrenKey = node[childrenKey]) === null || _node$childrenKey === void 0 ? void 0 : _node$childrenKey.length) > 0) {\n        formatted[childrenKey] = getFormattedTree(formatted[childrenKey], nodes, props);\n      }\n    }\n\n    return formatted;\n  });\n}\nexport function getDisabledState(nodes, node, props) {\n  var _props$disabledItemVa = props.disabledItemValues,\n      disabledItemValues = _props$disabledItemVa === void 0 ? [] : _props$disabledItemVa,\n      valueKey = props.valueKey;\n\n  if (_isNil(nodes[node.refKey])) {\n    return false;\n  }\n\n  return disabledItemValues.some(function (value) {\n    return shallowEqual(nodes[node.refKey][valueKey], value);\n  });\n}\nexport function getCheckTreePickerDefaultValue(value, uncheckableItemValues) {\n  if (Array.isArray(value)) {\n    return value.filter(function (v) {\n      return !uncheckableItemValues.includes(v);\n    });\n  }\n\n  return [];\n}\nexport function getSelectedItems(nodes, value, valueKey) {\n  var checkItems = [];\n  Object.keys(nodes).map(function (refKey) {\n    var node = nodes[refKey];\n\n    if (value.some(function (value) {\n      return shallowEqual(node[valueKey], value);\n    })) {\n      checkItems.push(node);\n    }\n  });\n  return checkItems;\n}\nexport function getNodeCheckState(_ref) {\n  var nodes = _ref.nodes,\n      node = _ref.node,\n      cascade = _ref.cascade,\n      childrenKey = _ref.childrenKey;\n\n  if (_isNil(nodes[node.refKey])) {\n    return CHECK_STATE.UNCHECK;\n  }\n\n  if (!node[childrenKey] || !node[childrenKey].length || !cascade) {\n    nodes[node.refKey].checkAll = false;\n    return node.check ? CHECK_STATE.CHECK : CHECK_STATE.UNCHECK;\n  }\n\n  if (isEveryChildChecked(nodes, node)) {\n    nodes[node.refKey].checkAll = true;\n    nodes[node.refKey].check = true;\n    return CHECK_STATE.CHECK;\n  }\n\n  if (isSomeChildChecked(nodes, node)) {\n    nodes[node.refKey].checkAll = false;\n    return CHECK_STATE.INDETERMINATE;\n  }\n\n  return CHECK_STATE.UNCHECK;\n}"]},"metadata":{},"sourceType":"module"}