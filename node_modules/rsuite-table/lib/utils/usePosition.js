"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports["default"] = void 0;

var _react = require("react");

var _domLib = require("dom-lib");

var _constants = require("../constants");

var _toggleClass = _interopRequireDefault(require("./toggleClass"));

var _useUpdateEffect = _interopRequireDefault(require("./useUpdateEffect"));

/**
 * Update the position of the table according to the scrolling information of the table.
 * @param props
 * @returns
 */
var usePosition = function usePosition(props) {
  var data = props.data,
      height = props.height,
      tableWidth = props.tableWidth,
      tableRef = props.tableRef,
      prefix = props.prefix,
      translateDOMPositionXY = props.translateDOMPositionXY,
      wheelWrapperRef = props.wheelWrapperRef,
      headerWrapperRef = props.headerWrapperRef,
      affixHeaderWrapperRef = props.affixHeaderWrapperRef,
      tableHeaderRef = props.tableHeaderRef,
      scrollX = props.scrollX,
      scrollY = props.scrollY,
      contentWidth = props.contentWidth,
      shouldFixedColumn = props.shouldFixedColumn;
  var getScrollCellGroups = (0, _react.useCallback)(function () {
    var _tableRef$current;

    return (_tableRef$current = tableRef.current) === null || _tableRef$current === void 0 ? void 0 : _tableRef$current.querySelectorAll("." + prefix('cell-group-scroll'));
  }, [prefix, tableRef]);
  var getFixedLeftCellGroups = (0, _react.useCallback)(function () {
    var _tableRef$current2;

    return (_tableRef$current2 = tableRef.current) === null || _tableRef$current2 === void 0 ? void 0 : _tableRef$current2.querySelectorAll("." + prefix('cell-group-fixed-left'));
  }, [prefix, tableRef]);
  var getFixedRightCellGroups = (0, _react.useCallback)(function () {
    var _tableRef$current3;

    return (_tableRef$current3 = tableRef.current) === null || _tableRef$current3 === void 0 ? void 0 : _tableRef$current3.querySelectorAll("." + prefix('cell-group-fixed-right'));
  }, [prefix, tableRef]);
  var updatePositionByFixedCell = (0, _react.useCallback)(function () {
    var wheelGroupStyle = {};
    var wheelStyle = {};
    var scrollGroups = getScrollCellGroups();
    var fixedLeftGroups = getFixedLeftCellGroups();
    var fixedRightGroups = getFixedRightCellGroups();
    translateDOMPositionXY.current(wheelGroupStyle, scrollX.current, 0);
    translateDOMPositionXY.current(wheelStyle, 0, scrollY.current);
    var scrollArrayGroups = Array.from(scrollGroups);

    for (var i = 0; i < scrollArrayGroups.length; i++) {
      var group = scrollArrayGroups[i];
      (0, _domLib.addStyle)(group, wheelGroupStyle);
    }

    if (wheelWrapperRef !== null && wheelWrapperRef !== void 0 && wheelWrapperRef.current) {
      (0, _domLib.addStyle)(wheelWrapperRef.current, wheelStyle);
    }

    var leftShadowClassName = prefix('cell-group-left-shadow');
    var rightShadowClassName = prefix('cell-group-right-shadow');
    var showLeftShadow = scrollX.current < 0;
    var showRightShadow = tableWidth.current - contentWidth.current - _constants.SCROLLBAR_WIDTH !== scrollX.current;
    (0, _toggleClass["default"])(fixedLeftGroups, leftShadowClassName, showLeftShadow);
    (0, _toggleClass["default"])(fixedRightGroups, rightShadowClassName, showRightShadow);
  }, [contentWidth, getFixedLeftCellGroups, getFixedRightCellGroups, getScrollCellGroups, prefix, scrollX, scrollY, tableWidth, translateDOMPositionXY, wheelWrapperRef]);
  var updatePosition = (0, _react.useCallback)(function () {
    // When there are fixed columns.
    if (shouldFixedColumn) {
      updatePositionByFixedCell();
    } else {
      var _affixHeaderElement$h;

      var wheelStyle = {};
      var headerStyle = {};
      translateDOMPositionXY.current(wheelStyle, scrollX.current, scrollY.current);
      translateDOMPositionXY.current(headerStyle, scrollX.current, 0);
      var wheelElement = wheelWrapperRef === null || wheelWrapperRef === void 0 ? void 0 : wheelWrapperRef.current;
      var headerElement = headerWrapperRef === null || headerWrapperRef === void 0 ? void 0 : headerWrapperRef.current;
      var affixHeaderElement = affixHeaderWrapperRef === null || affixHeaderWrapperRef === void 0 ? void 0 : affixHeaderWrapperRef.current;
      wheelElement && (0, _domLib.addStyle)(wheelElement, wheelStyle);
      headerElement && (0, _domLib.addStyle)(headerElement, headerStyle);

      if (affixHeaderElement !== null && affixHeaderElement !== void 0 && (_affixHeaderElement$h = affixHeaderElement.hasChildNodes) !== null && _affixHeaderElement$h !== void 0 && _affixHeaderElement$h.call(affixHeaderElement)) {
        (0, _domLib.addStyle)(affixHeaderElement === null || affixHeaderElement === void 0 ? void 0 : affixHeaderElement.firstChild, headerStyle);
      }
    }

    if (tableHeaderRef !== null && tableHeaderRef !== void 0 && tableHeaderRef.current) {
      (0, _toggleClass["default"])(tableHeaderRef.current, prefix('cell-group-shadow'), scrollY.current < 0);
    }
  }, [affixHeaderWrapperRef, headerWrapperRef, prefix, scrollX, scrollY, shouldFixedColumn, tableHeaderRef, translateDOMPositionXY, updatePositionByFixedCell, wheelWrapperRef]);
  (0, _useUpdateEffect["default"])(function () {
    if (scrollY.current !== 0) {
      updatePosition();
    }
  }, [height, data]);
  return {
    forceUpdatePosition: updatePosition
  };
};

var _default = usePosition;
exports["default"] = _default;