"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports["default"] = void 0;

var _react = require("react");

var _domLib = require("dom-lib");

var _requestAnimationTimeout = require("./requestAnimationTimeout");

var _useUpdateEffect = _interopRequireDefault(require("./useUpdateEffect"));

var _useMount = _interopRequireDefault(require("./useMount"));

var _constants = require("../constants");

/**
 * Add scroll, touch, and wheel monitoring events to the table,
 * and update the scroll position of the table.
 * @param props
 * @returns
 */
var useScrollListener = function useScrollListener(props) {
  var data = props.data,
      children = props.children,
      autoHeight = props.autoHeight,
      tableBodyRef = props.tableBodyRef,
      scrollbarXRef = props.scrollbarXRef,
      scrollbarYRef = props.scrollbarYRef,
      disabledScroll = props.disabledScroll,
      loading = props.loading,
      tableRef = props.tableRef,
      contentWidth = props.contentWidth,
      tableWidth = props.tableWidth,
      scrollY = props.scrollY,
      minScrollY = props.minScrollY,
      minScrollX = props.minScrollX,
      scrollX = props.scrollX,
      setScrollX = props.setScrollX,
      setScrollY = props.setScrollY,
      virtualized = props.virtualized,
      forceUpdatePosition = props.forceUpdatePosition,
      onScroll = props.onScroll,
      onTouchMove = props.onTouchMove,
      onTouchStart = props.onTouchStart,
      height = props.height,
      getTableHeight = props.getTableHeight,
      contentHeight = props.contentHeight,
      headerHeight = props.headerHeight,
      rtl = props.rtl;
  var wheelListener = (0, _react.useRef)();
  var touchStartListener = (0, _react.useRef)();
  var touchMoveListener = (0, _react.useRef)();

  var _useState = (0, _react.useState)(false),
      isScrolling = _useState[0],
      setScrolling = _useState[1];

  var touchX = (0, _react.useRef)(0);
  var touchY = (0, _react.useRef)(0);
  var disableEventsTimeoutId = (0, _react.useRef)(null);
  var shouldHandleWheelX = (0, _react.useCallback)(function (delta) {
    if (delta === 0 || disabledScroll || loading) {
      return false;
    }

    return true;
  }, [disabledScroll, loading]);
  var shouldHandleWheelY = (0, _react.useCallback)(function (delta) {
    if (delta === 0 || disabledScroll || loading) {
      return false;
    }

    return delta >= 0 && scrollY.current > minScrollY.current || delta < 0 && scrollY.current < 0;
  }, [disabledScroll, loading, minScrollY, scrollY]);
  var debounceScrollEndedCallback = (0, _react.useCallback)(function () {
    disableEventsTimeoutId.current = null;
    setScrolling(false);
  }, []);
  var handleWheel = (0, _react.useCallback)(function (deltaX, deltaY) {
    if (!tableRef.current) {
      return;
    }

    var nextScrollX = contentWidth.current <= tableWidth.current ? 0 : scrollX.current - deltaX;
    var nextScrollY = scrollY.current - deltaY;
    var y = Math.min(0, nextScrollY < minScrollY.current ? minScrollY.current : nextScrollY);
    var x = Math.min(0, nextScrollX < minScrollX.current ? minScrollX.current : nextScrollX);
    setScrollX(x);
    setScrollY(y);
    onScroll === null || onScroll === void 0 ? void 0 : onScroll(Math.abs(x), Math.abs(y));
    forceUpdatePosition();

    if (virtualized) {
      setScrolling(true);

      if (disableEventsTimeoutId.current) {
        (0, _requestAnimationTimeout.cancelAnimationTimeout)(disableEventsTimeoutId.current);
      }

      disableEventsTimeoutId.current = (0, _requestAnimationTimeout.requestAnimationTimeout)(debounceScrollEndedCallback, 0);
    }
  }, [contentWidth, debounceScrollEndedCallback, minScrollX, minScrollY, onScroll, scrollX, scrollY, setScrollX, setScrollY, tableRef, tableWidth, forceUpdatePosition, virtualized]);
  var listenWheel = (0, _react.useCallback)(function (deltaX, deltaY) {
    var _scrollbarXRef$curren, _scrollbarXRef$curren2, _scrollbarYRef$curren, _scrollbarYRef$curren2;

    handleWheel(deltaX, deltaY);
    (_scrollbarXRef$curren = scrollbarXRef.current) === null || _scrollbarXRef$curren === void 0 ? void 0 : (_scrollbarXRef$curren2 = _scrollbarXRef$curren.onWheelScroll) === null || _scrollbarXRef$curren2 === void 0 ? void 0 : _scrollbarXRef$curren2.call(_scrollbarXRef$curren, deltaX);
    (_scrollbarYRef$curren = scrollbarYRef.current) === null || _scrollbarYRef$curren === void 0 ? void 0 : (_scrollbarYRef$curren2 = _scrollbarYRef$curren.onWheelScroll) === null || _scrollbarYRef$curren2 === void 0 ? void 0 : _scrollbarYRef$curren2.call(_scrollbarYRef$curren, deltaY);
  }, [handleWheel, scrollbarXRef, scrollbarYRef]);
  var wheelHandler = (0, _react.useRef)(); // When handling the Touch event on the mobile terminal, initialize x and y when Start.

  var handleTouchStart = (0, _react.useCallback)(function (event) {
    if (event.touches) {
      var _event$touches$ = event.touches[0],
          pageX = _event$touches$.pageX,
          pageY = _event$touches$.pageY;
      touchX.current = pageX;
      touchY.current = pageY;
    }

    onTouchStart === null || onTouchStart === void 0 ? void 0 : onTouchStart(event);
  }, [onTouchStart]); // Handle Touch events on the mobile terminal, initialize when Move, and update the scroll bar.

  var handleTouchMove = (0, _react.useCallback)(function (event) {
    if (event.touches) {
      var _event$preventDefault, _scrollbarXRef$curren3, _scrollbarXRef$curren4, _scrollbarYRef$curren3, _scrollbarYRef$curren4;

      var _event$touches$2 = event.touches[0],
          pageX = _event$touches$2.pageX,
          pageY = _event$touches$2.pageY;
      var deltaX = touchX.current - pageX;
      var deltaY = autoHeight ? 0 : touchY.current - pageY;

      if (!shouldHandleWheelY(deltaY) && !shouldHandleWheelX(deltaX)) {
        return;
      }

      (_event$preventDefault = event.preventDefault) === null || _event$preventDefault === void 0 ? void 0 : _event$preventDefault.call(event);
      handleWheel(deltaX, deltaY);
      (_scrollbarXRef$curren3 = scrollbarXRef.current) === null || _scrollbarXRef$curren3 === void 0 ? void 0 : (_scrollbarXRef$curren4 = _scrollbarXRef$curren3.onWheelScroll) === null || _scrollbarXRef$curren4 === void 0 ? void 0 : _scrollbarXRef$curren4.call(_scrollbarXRef$curren3, deltaX);
      (_scrollbarYRef$curren3 = scrollbarYRef.current) === null || _scrollbarYRef$curren3 === void 0 ? void 0 : (_scrollbarYRef$curren4 = _scrollbarYRef$curren3.onWheelScroll) === null || _scrollbarYRef$curren4 === void 0 ? void 0 : _scrollbarYRef$curren4.call(_scrollbarYRef$curren3, deltaY);
      touchX.current = pageX;
      touchY.current = pageY;
    }

    onTouchMove === null || onTouchMove === void 0 ? void 0 : onTouchMove(event);
  }, [autoHeight, handleWheel, onTouchMove, scrollbarXRef, scrollbarYRef, shouldHandleWheelX, shouldHandleWheelY]);
  var handleHorizontalScroll = (0, _react.useCallback)(function (delta) {
    handleWheel(delta, 0);
  }, [handleWheel]);
  var handleVerticalScroll = (0, _react.useCallback)(function (delta) {
    handleWheel(0, delta);
  }, [handleWheel]);
  /**
   * When the user uses the tab key in the Table, the onScroll event is triggered,
   * and the scroll bar position should be updated at the same time.
   * https://github.com/rsuite/rsuite/issues/234
   */

  var handleBodyScroll = (0, _react.useCallback)(function (event) {
    if (event.target !== tableBodyRef.current) {
      return;
    }

    var left = (0, _domLib.scrollLeft)(event.target);
    var top = (0, _domLib.scrollTop)(event.target);

    if (top === 0 && left === 0) {
      return;
    }

    listenWheel(left, top);
    (0, _domLib.scrollLeft)(event.target, 0);
    (0, _domLib.scrollTop)(event.target, 0);
  }, [listenWheel, tableBodyRef]);
  var getControlledScrollTopValue = (0, _react.useCallback)(function (value) {
    if (autoHeight) {
      return [0, 0];
    }

    var height = getTableHeight(); // The maximum range of scrolling value is judged.

    value = Math.min(value, Math.max(0, contentHeight.current - (height - headerHeight))); // The value is a value of the theoretical scroll position of the table,
    // and the scrollY coordinate value and the value of the scroll bar position are calculated by value.

    return [-value, value / contentHeight.current * (height - headerHeight)];
  }, [autoHeight, contentHeight, getTableHeight, headerHeight]);

  var rerender = function rerender() {
    setScrolling(true);
    setTimeout(function () {
      return setScrolling(false);
    }, 0);
  };

  var getControlledScrollLeftValue = function getControlledScrollLeftValue(value) {
    // The maximum range of scrolling value is judged.
    value = Math.min(value, Math.max(0, contentWidth.current - tableWidth.current));
    return [-value, value / contentWidth.current * tableWidth.current];
  };

  var handleScrollTop = function handleScrollTop(top) {
    var _scrollbarYRef$curren5, _scrollbarYRef$curren6;

    if (top === void 0) {
      top = 0;
    }

    var _getControlledScrollT = getControlledScrollTopValue(top),
        nextScrollY = _getControlledScrollT[0],
        handleScrollY = _getControlledScrollT[1];

    setScrollY(nextScrollY);
    scrollbarYRef === null || scrollbarYRef === void 0 ? void 0 : (_scrollbarYRef$curren5 = scrollbarYRef.current) === null || _scrollbarYRef$curren5 === void 0 ? void 0 : (_scrollbarYRef$curren6 = _scrollbarYRef$curren5.resetScrollBarPosition) === null || _scrollbarYRef$curren6 === void 0 ? void 0 : _scrollbarYRef$curren6.call(_scrollbarYRef$curren5, handleScrollY);
    forceUpdatePosition();
    onScroll === null || onScroll === void 0 ? void 0 : onScroll(Math.abs(scrollX.current), Math.abs(nextScrollY));
    /**
     * After calling `scrollTop`, a white screen will appear when `virtualized` is true.
     * The reason is that the coordinates of the DOM are directly manipulated,
     * but the component is not re-rendered. Need to call `rerender`.
     * Fix: rsuite#1044
     */

    if (virtualized && contentHeight.current > height) {
      rerender();
    }
  };

  var handleScrollLeft = function handleScrollLeft(left) {
    var _scrollbarXRef$curren5, _scrollbarXRef$curren6;

    if (left === void 0) {
      left = 0;
    }

    var _getControlledScrollL = getControlledScrollLeftValue(left),
        nextScrollX = _getControlledScrollL[0],
        scrollbarX = _getControlledScrollL[1];

    setScrollX(nextScrollX);
    onScroll === null || onScroll === void 0 ? void 0 : onScroll(Math.abs(nextScrollX), Math.abs(scrollY.current));
    scrollbarXRef === null || scrollbarXRef === void 0 ? void 0 : (_scrollbarXRef$curren5 = scrollbarXRef.current) === null || _scrollbarXRef$curren5 === void 0 ? void 0 : (_scrollbarXRef$curren6 = _scrollbarXRef$curren5.resetScrollBarPosition) === null || _scrollbarXRef$curren6 === void 0 ? void 0 : _scrollbarXRef$curren6.call(_scrollbarXRef$curren5, scrollbarX);
    forceUpdatePosition();
  };

  var handleScrollTo = function handleScrollTo(coord) {
    var _ref = coord || {},
        x = _ref.x,
        y = _ref.y;

    if (typeof x === 'number') {
      handleScrollLeft(x);
    }

    if (typeof y === 'number') {
      handleScrollTop(y);
    }
  };

  (0, _useUpdateEffect["default"])(function () {
    handleScrollLeft(0);
  }, [children, contentWidth.current]);
  (0, _useUpdateEffect["default"])(function () {
    if (scrollY.current !== 0) {
      handleScrollTop(Math.abs(scrollY.current));
    }
  }, [height, data]);
  (0, _react.useEffect)(function () {
    var options = {
      passive: false
    };
    var tableBody = tableBodyRef.current;

    if (tableBody) {
      wheelHandler.current = new _domLib.WheelHandler(listenWheel, shouldHandleWheelX, shouldHandleWheelY, false);
      wheelListener.current = (0, _domLib.on)(tableBody, 'wheel', wheelHandler.current.onWheel, options);
      touchStartListener.current = (0, _domLib.on)(tableBody, 'touchstart', handleTouchStart, options);
      touchMoveListener.current = (0, _domLib.on)(tableBody, 'touchmove', handleTouchMove, options);
    }

    return function () {
      var _wheelListener$curren, _touchStartListener$c, _touchMoveListener$cu;

      wheelHandler.current = null;
      (_wheelListener$curren = wheelListener.current) === null || _wheelListener$curren === void 0 ? void 0 : _wheelListener$curren.off();
      (_touchStartListener$c = touchStartListener.current) === null || _touchStartListener$c === void 0 ? void 0 : _touchStartListener$c.off();
      (_touchMoveListener$cu = touchMoveListener.current) === null || _touchMoveListener$cu === void 0 ? void 0 : _touchMoveListener$cu.off();
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [data]);
  (0, _useMount["default"])(function () {
    if (rtl) {
      var _scrollbarXRef$curren7, _scrollbarXRef$curren8;

      // Initialize scroll position
      setScrollX(tableWidth.current - contentWidth.current - _constants.SCROLLBAR_WIDTH);
      scrollbarXRef === null || scrollbarXRef === void 0 ? void 0 : (_scrollbarXRef$curren7 = scrollbarXRef.current) === null || _scrollbarXRef$curren7 === void 0 ? void 0 : (_scrollbarXRef$curren8 = _scrollbarXRef$curren7.resetScrollBarPosition) === null || _scrollbarXRef$curren8 === void 0 ? void 0 : _scrollbarXRef$curren8.call(_scrollbarXRef$curren7, -scrollX.current);
      forceUpdatePosition();
    }
  });
  return {
    isScrolling: isScrolling,
    handleHorizontalScroll: handleHorizontalScroll,
    handleVerticalScroll: handleVerticalScroll,
    handleBodyScroll: handleBodyScroll,
    handleScrollTop: handleScrollTop,
    handleScrollLeft: handleScrollLeft,
    handleScrollTo: handleScrollTo
  };
};

var _default = useScrollListener;
exports["default"] = _default;